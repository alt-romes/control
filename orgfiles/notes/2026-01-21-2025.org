#+title: Linear Types
#+author: Rodrigo Mesquita
#+bibliography: references.bib
#+date: <2026-01-21 Wed>

* Linear Types

   Linear types correspond to Linear Logic [cite:@GIRARD19871], via the
   Curry-Howard isomorphism [cite:@Howard1969TheFN].

* Introduction to Linear Types in Haskell

** Introduction

   Linear types increase the expressiveness of Haskell by making it possible to
   restrict the way certain resources are used. Namely, they introduce /linear functions/.
   The key definition for working with linear types is:

   #+BEGIN_CENTER
    A linear function consumes its argument *exactly once*
   #+END_CENTER

   Example
   #+BEGIN_SRC haskell

   id :: a %1 -> a
   id x = x

   id' :: a ⊸ a
   id' x = x

   tuple :: a %1 -> b %1 -> (a, b)
   tuple a b = (a, b)

   fst :: (a, b) %1 -> a
   fst (a, b) = a

   snd :: (a, b) %1 -> b
   snd (a, b) = b

   swap :: (a, b) %1 -> (b, a)
   swap (a, b) = (b, a)

   inl :: a %1 -> Either b a
   inl a = Left a

   inr :: b %1 -> Either a b
   inr b = Right b

   #+END_SRC

   Example with good logic analogy (typically having A -> B, A -> C, A |- B ^ C, but this is not true in Linear Logic!)
   #+BEGIN_SRC haskell

   f :: (a -> b) -> (a -> c) -> a -> (b, c)
   f a2b a2c a = (a2b a, a2c a)

   -- Not true in Linear Haskell!
   f :: (a ⊸ b) ⊸ (a ⊸ c) ⊸ a ⊸ (b, c)
   f a2b a2c a = (a2b a, a2c a)

   #+END_SRC

   A more precise definition can be taken from the [[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/linear_types.html][GHC's user guide]]:
   #+BEGIN_QUOTE
   A function ~f~ is linear if: when its result is consumed exactly once, then
   its argument is consumed exactly once. Intuitively, it means that in every
   branch of the definition of ~f~, its argument ~x~ must be used exactly once.
   Which can be done by

   - Returning ~x~ unmodified.
   - Passing ~x~ to a linear function and using the result exactly once in the same fashion.
   - Pattern-matching on ~x~ and using each argument exactly once in the same fashion.
   - Calling it as a function and using the result exactly once in the same fashion.
   #+END_QUOTE

   Linear types were added to Haskell in GHC 9.0 (roughly 5 years ago).

*** Encodings

   It's not easy nor practical to encode linear types in a non-linearly typed
    language. See, for instance, [[https://stackoverflow.com/a/34231618][András Kovács encoding using indexed monads]], or
    [[https://dl.acm.org/doi/10.1145/2887747.2804309][Embedding a Full Linear Lambda Calculus in Haskell]] [cite:@10.1145/2887747.2804309].

   Fundamentally, that's because linear types require taking away something
    which is taken for granted in most languages: /weakening/ and /contraction/.
    In other words, linear types take away the ability to freely forget and
    duplicate (linear) variables.

** Motivation for Linear Types

   It may seem useless to restrict an integer to be used exactly once...
   However, with a bit creativity, we can see pointers, file handles, GPU allocated memory, Vulkan resources...
   Also: security, deadlock freedom with session types, ...

** Linear Haskell

   By default, all datatypes have linear fields:

   #+begin_src haskell
   data T1 a = MkT1 a

   mk :: a %1 -> T1
   mk x = T1 x
   #+end_src

   But if we use GADT syntax, we can specify the multiplicity of the datatype
   arrows:
   #+begin_src haskell
   data T1 a where
    MkT1 :: a -> T1 a -- Note the unrestricted arrow

   mk :: a %1 -> T1
   mk x = T1 x
   #+end_src

   When you match on a constructor, you need to consume all its linear fields linearly, or *exactly once*
   #+begin_src haskell
   data T2 a b where
    MkT1 :: a %1 -> b -> T2 a b -- a is linear, b is unrestricted

   take :: T2 a b %1 -> (a, b, b)
   take (T2 x y) = (x, y, y)

   bad :: T2 a b %1 -> (a, a, b, b)
   bad (T2 x y) = (x, x, y, y)
   #+end_src

*** Multiplicity polymorphism

    In ~a %1 -> b~ we say ~a~ has multiplicity ~1~, or ~One~.
    We could also specify the multiplicity to be unrestricted, written ~Many~.

    Example using a normal function as a higher order function, like map

    Can we define map with mult poly?


** Linear Base


   [[https://hackage.haskell.org/package/linear-base][linear-base]]

   Makes programming with linear types much more convenient, and brings interesting linearly-typed abstractions.
   Example: Mutable, pure, linear arrays. In place mutation made possible (at
   the library level) because linearly typed API constrains how the user can
   use the mutable array.

   Introducing: Ur

   #+begin_src haskell
   data Ur a where
     Ur :: a -> Ur a
   -- (Ur a ⊸ b) and (a -> b) are equivalent. The argument is unrestricted
   #+end_src

*** Linearity as a property of the function, not value

    How to construct APIs which can leverage linearity? CPS

*** Linear IO and a tale of two functors

    [[https://www.tweag.io/blog/2020-01-16-data-vs-control/][A tale of two functors]]

    - Data functor vs Control functor

    Linear Monad guarantees a resource "in the monad" can only be used by `>>=` which takes a linear continuation (guaranteeing that the value is always threaded linearly)

    Linear IO guarantees all resources created in linear IO are used linearly.


*** CPS based APIs

    For a linearly-typed api you need to require of your user a function which guaranteedly will use the resource exactly once. You never give the resource to the user.
    You just pass your resource to the linear continuation the user gives you and you ensure the user can only use and modify that resource using the linearly typed API that you give it.

    More examples: linear-text-builder

** Exercises

   #+begin_src haskell

   -- A ⊗ (B ⊕ C) ≣ (A ⊗ B) ⊕ (A ⊗ C)
   proof1 :: (a, Either b c) %1 -> Either (a, b) (a, c)
   proof1 = _

   #+end_src

   Exercise: implement ~meshNormalise~ in [[file:code/linear-mutable-arrays/app/Main.hs]]

** Further reading:

- Linear Haskell paper
- [[https://www.cs.cornell.edu/courses/cs4110/2018fa/lectures/lecture29.pdf][(CMU) CS 4110 – Programming Languages and Logics Lecture #29: Linear Types]]
- [[https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/linear_types.html][GHC's user guide on Linear Types]]


