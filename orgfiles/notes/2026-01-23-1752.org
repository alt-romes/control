#+title: Fixing e-graphs and eq-sat
#+date: [2026-01-23 Fri 17:40]

* Exploration: Fixing e-graphs and eq-sat

  Represent (a*2)/2, a << 1, a*(2/2), a*1, a in e-graph using low-level primitives

  #+begin_src haskell

  data Expr a
    = K Float
    | S Char
    | M a a
    | D a a
    | SHL a a

  -- simulate eq-sat on (a*2)/2:
  -- construct an e-graph which represents
  -- both and observes equivalence relation
  repExpr = do
    -- (a*2)/2
    c1 <- add (S 'a')
    c2 <- add (K 2)
    c3 <- add (M c1 c2)
    c4 <- add (D c3 c2)

    -- (a<<1)
    c5 <- add (K 1)
    c6 <- add (SHL c1 c5)

    -- (a*2) ~ (a<<1)
    c7 <- merge c3 c6

    -- a*(2/2)
    c8 <- add (D c2 c2)
    c9 <- add (M c1 c8)

    -- (a*2)/2 ~ a*(2/2)
    c10 <- merge c9 c4
    -- (2/2) ~ 1
    c11 <- merge c8 c5
    -- a*1 ~ a
    c12 <- merge c9 c5

    return c4

  #+end_src

  Using ~Expr a~ is neat because it allows us to interpret ~a~ in at least two relevant ways:

    1. ~a~ can be instantiated at a specific sub-expression (using ~Fix~)

    2. or, ~a~ can be instantiated s.t. all equivalent sub-expressions are
     represented by a particular ~a~
        - Like ~a~ as the e-class representitive (trivially, using a ~ClassId~)

    3. Later, it will also allow ~a~ to stand for a pattern variable, when
     defining rewrite rules

  Can we tie the knot in a way where the final assigned e-class is circularly
  defined to be the final one at all points?
  #+begin_src haskell
  -- circularly defined, but requires something about how multiple things adds
  -- return the same representative hmm...
  repExpr = do
    -- (a*2)/2
    c1 <- add (S 'a')
    c2 <- add (K 2)
    c3 <- add (M c1 c2)
    c4 <- add (D c3 c2)

    -- (a<<1)
    c4 <- add (K 1)
    c3 <- add (SHL c1 c4)

    -- a*(2/2)
    c4 <- add (D c2 c2)
    c4 <- add (M c1 c4)

    return c4
  #+end_src

  If we interpreted a free-monad like definition of the above expression, could
  we batch all adds of things which were merged? Would this work?
  #+begin_src haskell
  repExpr = do
    c1 <- add [(S 'a')]
    c2 <- add [(K 2)]
    c3 <- add [(M c1 c2), (SHL c1 c4)]
    c4 <- add [(D c3 c2), (K 1), (D c2 c2), (M c1 c4)]
    return c4
  #+end_src

  Or is it a cofree comonad?

** The ways invariants are broken

   On `add`, we just have to make sure that adding e-node A many times always
   yields the same class id.

   On `merge`, harder.

** Magic from EgrT to Egr

   EgrT to Egr, where Egr is the version in which all knots have been tied
   Basically, how to go from ~repExpr~ to ~repExprFinal~?

   It looks like this is essentially going to be the proper e-graph implementation.
   We likely need to keep the Hashcons for ~add~ here, and the worklist with
   rebuilding for ~merge~ as we traverse down?

   We could potentially amortize the cost further by observing the merge/add
   structure to avoid or reduce work. Just like the worklist.

* Attempts

** Getting somewhere

   The big question is how to turn ~repExpr~ into ~repExprFinal~, with all the
   sharing?

   A second question is whether this is too limiting, in the sense it's harder
   to ~extract~ from an arbitrary eclass in the egraph.

  #+begin_src haskell

  data Expr a
    = K Float
    | S Char
    | M a a
    | D a a
    | SHL a a
    deriving (Functor, Foldable, Traversable, Eq, Ord, Show)

  data EgrT l v
    = Pure v -- monad?
    | Add (l v) (v -> EgrT l v) -- PHOAS?
    | Merge v v (EgrT l v)

  repExpr :: EgrT Expr v
  repExpr =
    -- (a*2)/2
    add (S 'a')   $ \c1 ->
    add (K 2)     $ \c2 ->
    add (M c1 c2) $ \c3 ->
    add (D c3 c2) $ \c4 ->
 
    -- (a<<1)
    add (K 1)       $ \c5 ->
    add (SHL c1 c5) $ \c6 ->
 
    -- (a*2) ~ (a<<1)
    merge c3 c6     $
 
    -- a*(2/2)
    add (D c2 c2) $ \c8 -> 
    add (M c1 c8) $ \c9 -> 
 
    -- (a*2)/2 ~ a*(2/2)
    merge c9 c4 $
    -- (2/2) ~ 1
    merge c8 c5 $
    -- a*1 ~ a
    merge c9 c5 $
 
    Pure c4
 
  newtype EClass l = EClass { enodes :: [l (EClass l)] }
  deriving instance Show (l (EClass l)) => Show (EClass l)
 
  -- Reduce to:
  repExprFinal :: EClass Expr
  repExprFinal = do
    let c1 = EClass [S 'a']
        c2 = EClass [K 2]
        c3 = EClass [M c1 c2, SHL c1 c4]
        c4 = EClass [D c3 c2, K 1, D c2 c2, M c1 c4]
     in c4
 
  extract :: EClass Expr -> Fix Expr
  extract cl = case best cl of
    K a -> Fix (K a)
    S s -> Fix (S s)
    M a b -> Fix $ M (extract a) (extract b)
    D a b -> Fix $ D (extract a) (extract b)
    SHL a b -> Fix $ M (extract a) (extract b)
 
  best (EClass l) = head $ sortOn bestLazy l
 
  -- todo: recursion schemes rather than this hack,
  -- also, how to do this well?
  bestLazy :: Expr (EClass Expr) -> [Int]
  bestLazy x = case x of
    K a -> [0]
    S s -> [0]
    M a b -> [1] ++ bestLazy (best a) ++ bestLazy (best b)
    D a b -> [5] ++ bestLazy (best a) ++ bestLazy (best b)
    SHL a b -> [2] ++ bestLazy (best a) ++ bestLazy (best b)
 
  #+end_src

* References

  1. Using Circular Programs for Higher-Order Syntax (Functional pearl)
        - And Ed Kmett's post for doing it faster
  2. Parametric Higher-Order Abstract Syntax for Mechanized Semantics
        - subst : ∀v. term(term(v)) → term(v)
  3. [[https://coot.me/posts/free-monads.html][From free algebras to free monads]]
