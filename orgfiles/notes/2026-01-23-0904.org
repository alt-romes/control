#+title: Call notes Nick Wu
#+date: [2026-01-23 Fri 09:04] [2026-01-23 Fri 14:40]

* E-graphs

  E-graphs represents multiple expressions and maintain a congruence relationship ...

   add :: Enode -> Egraph -> ClassId

   -- Merge two eq-classes
   merge :: ClassId -> ClassId -> Egraph -> Egraph

   -- E-graph invariant: maintain congruence relation

   data Expr a
    = K Int
    | Plus a a

   type NExpr = Fix Expr

   add :: Expr ClassId -> Egraph -> ClassId
   merge :: ClassId -> ClassId -> Egraph -> Egraph

   represent :: Fix Expr -> Egraph -> ClassId
   represent (Plus (K 1) (K 2)) =
     c1 <- add (K 1)
     c2 <- add (K 2)
     add (Plus c1 c2)

   Nick: Good representation for free monads with theory
       - Free Monad gives you the terms, theory gives you the equivalence relation

   Trace:
   plus(a, b)  and   plus(a, c)
   merge b c --- only things which get "dirty" are parents of b and c
   plus(a, b) ~ plus(a, c)
   -- maintaining congruence relation  
    -- ends up being finding the fixpoint e-graph with the invariants rebuild

  Nick: sounds like a Comonad which gives rise to the loeb theorem

  Expr trick:
   Expr Pattern <-- Rewrwite rules
   Expr ClassId <-- egraphs
   Fix Expr <-- in your program


** Löb and Comonads

   loeb :: Comonad w => w (w a -> a) -> a

   extract :: w a -> a
   duplicate :: w a -> w (w a)
   extend :: w a -> (w a -> b) -> w b

   Nick: when I think of merge and congruence,
       it feels like duplicate and extend

   something with Ids, extract :: E-graph -> ClassId
   duplicate is saying something like, if I have a graph of Ids, I can make a
   graph of graph of Ids...

   ~w~ is Egraph, ~a~ is the set of all ids in the graph presently

   If we want to change an e-graph, ~a~ has to change! (depedent types...)

   ~emptyEGraph :: Egraph Void~
   
   ~extract :: Egraph a -> a~ -> give me all ids of the e-graph

   ~duplicate :: Egraph a -> Egraph (Egraph a)~ -> id space has become the space of all the nodes

** Equality Saturation(Fixpoint)

   Given a list of rewrite rules, and a starting e-graph representing some expressions,
   apply rewrite rules to the e-graph until a fixpoint is reached

   Rewrite = Pattern :=> Rhs

   Plus "a" "b"

   {a -> classId1, b -> classId2 }

   matches <- for lhs := rhs in rw
    subst, classid <- ematch eg lhs

   for (match, rhs) ..
    c <- represent (subst rhs)
    merge{construct a worklist} c match

   rebuild at end = dedup work list and repair invariants

   At the end, extract the best expression from the eq-class you are interested
   in.

** Rebuilding

    "Delay maintaining the invariants"

   Maybe we can delay merges TOO, not just rebuilding invariants
   Maybe we can delay ematching too by batching cartesian query (see databases below)...

   Nick: Really hoping to see comm or associative law, which would allow 

   merge/filter <=> filter/merge?
   POSTPONE merges until we can filter maximally. Get smaller merge.

*** Databases
    ICFP: "Relational Algebra by Way of Adjunctions" -- Same idea!
        - Delay the cartesian product, wait until we can filter out things on each branch of the cartesian product

    The relation algebra lets us treat a database as if it was a bunch of
    relations, to which we can apply operations etc...

    "Give all nodes in this graph, filtered by get(put) = ∅"

    Querying the e-graph to get a database, ...
    Database query returns the database filtered by things filtered by ....

** Analysis

   Attach data from semilattice to every equiv. class

    - make (node) = data
    - join data1 data2 = ...
    - modify eg data = ...

     modify(modify(c)) = c

    Nick: E-graph is actually a free semilattice, that we want to extend with additional information?

*** Free semilattice e-graphs

    No difference between merge and join
    merge is the e-graph join Lol!

    Best semilattice in our structure, which distinguishes more points to begin with
    Free-ness
        "Whenever we join two e-graphs together, we can also join the data together"

    Morphism from the egraph into datastructure with semilattice data

    Egraph a, where a will be BOTH
    ---: D from semilattice
    ---: a is the e-class ids...

    Morphism from ids to the lattices

    What about enodes?
        Each monomorphic e-node is given an eclass

    1*1:
    K 1   -> a
    * a a -> b
    merge a b
    b => a

    DATA:
    K 1 -> Just 1
    * a a -> Nothing
    merge K1 *aa
        Just 1 ^ Nothing
        => Just 1

    Mapping from Id of K1 and *aa to Data point will preserve the fact that they all point to just one
    (Nice commutting condition here... doesn't matter if the data is in each node or in a separate tree + a mapping)

    Every e-node is given an eclass unique up to equivalence on the ClassId

*** Semilattice

    The semilattice which represents the data in e-graph
    Points in semilattice ....?
    Join operation
    Bottom

*** Constant folding

    add (K 2) = Just 2
    join _ _ = error "better be 2"
    modify eg (Just 2) = prune out all nodes except for K 2

    Egraph ~a~, ~a~ 

    Strengthen ~a~ to set of things ...

** Typed indexes

   data Expr a
    = K Int
    | Plus a a

   data Expr a where
      Let :: Expr a -> (Expr a -> Expr b) -> Expr b
      LitF :: Double -> Expr Double
      LitI :: Int -> Expr Int
      ToF :: Expr Int -> Expr Double
      Floor :: Expr Double -> Expr Int
      Add :: Expr a -> Expr a -> Expr a

   Can you use these in recursions-schemes?
   Nick: Yes, right Kan extension.

   We can do that in a higher-functor world, but then we need to apply that
   construction to a particular value at some point. The Kan extension comes here?
   Adjuction between functor composition and right Kan extension is what gives
   rise to the Conjugate Hylomorphism for the cata...

   Do conjugate hylomorphisms in Haskell
        Yes and no: you need to be able to encode categories properly, but that's not so easy to do in Haskell.
        More so in theory than in practice.

   We could do the typed => untyped => typed version of this, but it'd be cooler to just have the more general version.
   We could attach the type as the data of the analysis...

   Egraph a ==> Double, Int, ...

   Egraph ____ ==>
    { K 1 } a
    { * a a } b
    { S "Hello" } c

** Variable id types and e-graphs for pattern match checking

   In GHC, we really want an e-graph where the Id type is ~Id~

** Category of ids and nodes

   N: Functor between category of ids and category nodes

** Free monad theory quotients

    Free monad over a signature (e.g. gets + puts)
        Theory/equations:
            get(put(x)) = x
    Free monad over gets and puts is a tree which distinguishes between puts and gets
        In a tree get(put(x)) is distinguished from x, but in an interpretation flatten this

    We can quotient the tree, which considers the equivalence relation given by the theory.
    Quotient of tree means we can't see the syntactic difference


** Equivalence Relation

   Relation which behaves like equality (refl, trns, ...)
   Equivalence relation, we mean "let's treat things as equal, even though
   they're not equal (just equiv)"

   Equivalence class: all things which are in equivalence relation to each other
   Can use the repr. element to represent everything else in the same eq-class
    [x] to mean x and all things equiv relation

   Congruence relation ==> equivalence relation
    (stronger, eq in all contx) vs (weaker, observationally equal)


* Further ideas

   - Coinductive structure of e-graphs?
   - Algebraic egraphs? Merge as a data constructors
   - ClassIds at all?
        - PHOAS would allow us to use Haskell's variables instead of ClassIds
        - "Fast Circular Substitution" http://comonad.com/reader/2014/fast-circular-substitution/
    
  If it's not union find, we could get away with the circular lazy fast things
    Union find not having good pure implementation doesn't imply an e-graph doesn't

  Upwards merging kind of requires ????

  - Propagators (Ed Kmett) https://github.com/ekmett/propagators
    - algorithm for network of stuff where communication things, you get strong
      guarantees of termination and efficiency just from the algebraic thing

* ?
   data Expr a
    = ...

   represent :: Fix Expr -> Egraph -> ClassId

   add :: Expr ClassId -> Egraph -> ClassId
   merge :: ClassId -> ClassId -> Egraph -> Egraph


   represent (K 1) -> 1
   represent (K 1) -> 1

   represent (K (1*1)) -> 2

   merge 2 1 -> 2

   UnionFind
    1 => 2

* Observations

  E-graph is a graph, we're performing union algorithm over that
    - What's the right implementation for this?

  Stop doing union find over structure after we hit the fixpoint

  Optimise construction of graph by taking least fixed point of expr coming in

  Similar to "Attribute Grammar" - constraints which guarantee you do get to a solution
  Spreadsheet, Löbs theorem

  E-graph similar to Union Find (needed complexity of union find)

  Need to add something to attribute grammars to make it more efficient
  
  Weighted search

  BFS over link structure

  Formalising Union Find in Idris

  plus(a, b)   ||     plus(a, c)
  merge b ~ c -> canonical id
  plus(a, b) ~ (a, c)

  b ~ c ~ d ~ e ~ a

  Observation: union find for my benchmarks didn't have very deep paths


  Take dynamic programming algorithm and then use rewrite rules whenever nodes are mentioned
  e.g. Edit distance problem
    Deletion=>Insertion <=> Insertion=>Deletion

  Pure and functional may end up being less elegant than pure way where we rely
  on a lot of laziness weird things. Then again...!

  There must be a good algebraic theory to apply to this stuff to make it better
    - Would still pull out of pure world
    - Suspect we may need to do mutation
        - Something that may come into this from the Phased mutations (Phased work)
        - Interleave some mutation as we go through this
        - Can't get away from the mutation with Ids
            - Unless we can do PHOAS thing.
            - Coinductive structure while doing mutation things. Looks like Phased work as well.

** List fusion
  OTOH: if we implemented something like list fusion, we'd see much deeper paths.

  Haskell list fusion -> Use build/foldr

*
   PHOAS with elimination for debruijn 

* Benchmarks for EqSat / EqGraphs

  - Knuth-Bendix algorithm could be an interesting benchmark as well
    (substring matching). **Really relevant**

